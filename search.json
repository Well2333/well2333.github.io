[{"title":"面对初学者的python开发环境配置","date":"2023-02-27T18:00:00.000Z","url":"/2023/02/28/%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/","categories":[["Python杂谈","/categories/Python%E6%9D%82%E8%B0%88/"]],"content":" ⚠警告受限于作者的知识储备与开发经验，文章中难免会出现错误或异想天开等不符合实际情况的暴论，请您谨慎甄别取用。如您发现错误结论或其他需要修改的问题，可发送电子邮件至 &#x77;&#101;&#108;&#108;&#x5f;&#x34;&#48;&#52;&#x40;&#x6f;&#117;&#x74;&#108;&#x6f;&#111;&#x6b;&#46;&#99;&#111;&#109; 以联系作者进行更正。 面对初学者的python开发环境配置在学习 python 的过程中，难免会遇到一些环境方面的问题，例如两个不同项目的依赖相互冲突，使用IDLE写代码太麻烦，写出来的的代码格式乱七八糟… 本文希望用一个相对简单易懂的方式，让大家能有一个可以长期使用的 Python 开发环境，并在之后逐步了解一些常用的开发工具。 开篇先叠甲本教程并不是一个十分严谨、客观且适用于所有人的环境组合，如果你的开发环境也很好用那么你大可不必切换到不熟悉的开发环境，毕竟自己用的舒服才是最重要的。 编辑器对于程序猿来说，技术层面最能提高工作效率的无疑是一款好的编辑器。 目前 Python 主流的代码编辑器有 Pycharm 和 VSCode 两款。 Pycharm or VSCode?Pycharm 是由 jetbrains 开发并发行的一款 Python 集成开发环境，拥有丰厚的历史底蕴。但由于功能繁多、配置复杂，对于新手上手较为困难，笔者曾多次遇到因不理解某些概念直接使用 Pycharm 造成的错误（如工作区错误，虚拟环境错误等）。同时其体积和内存消耗惊人，空载状态（打开一个空的文本文档）下就消耗了约1.5G的内存。因此除非你是 Pycharm 的老用户，否则并不推荐使用 Pycharm 进行开发。 VSCode 是由微软开发的开源免费的跨平台代码编辑器，得益于其庞大的插件市场，你几乎可以用 VSCode 对任意类型的代码进行编辑，对于 Python JavaScript TypeScript 等多种语言以及 Json Yaml Markdown HTML 等富文本均有十分良好的支持。由于 VSCode 起步较晚，其表现在初期并不如 jetbrains 的一众老牌编辑器，但目前笔者认为其功能和使用体验已经实现了全方位的赶超。同时，相较于 Pycharm 惊人的资源占用，VSCode 的空载状态（打开一个空的文本文档）下占用约为280M，但内存占用会随着安装的插件和打开的项目大小逐步增加，实际安装好对应插件并打开一个 Python 项目的占用约为 800M-1G 左右。 VSCode 的安装VSCode的安装方式可以参考菜鸟教程的这篇文章，其中详细的展示了VSCode的安装方法，在此容笔者偷个懒不做演示。 VSCode 插件插件系统算是 VSCode 的灵魂，是否正确的选择了插件对于编程来说会有截然不同的体验。 在按照上文安装完汉化包后，在输入框搜索 Python 并安装 Python 语言插件，并推荐安装 isort indent-rainbow SonarLint Sourcery 这几个辅助插件。 Python 语言插件是对代码提供高亮以及语法提示，是 VSCode 编写 Python 必备的插件。 isort 可以对你的 import 进行排序，需要在 Python 文件中需要通过右键菜单主动调用。 indent-rainbow 可以给你的代码缩进加上不同颜色的高亮，并对不符合缩进的部分标红。 SonarLint 可以帮助你发现代码中的潜在问题和不符合PEP规范的代码，并且也适用于多种不同的编程语言。可以参考插件介绍页面的动图了解其具体功能。 Sourcery 相对 SonarLint 不光可以提示你的错误，更可以直接帮助你修改代码，使其拥有更好的可读性。可以参考插件介绍页面的动图了解其具体功能。 完成以上这些插件的安装后，你就会得到一个舒适的代码编辑环境了。 虚拟环境虚拟环境，顾名思义是一个独立于其他环境的开发环境，就像是虚拟机之间一样，不同的虚拟机无法直接影响其他的虚拟机，虚拟环境也是如此。面对同时需要使用较多依赖、同时开发多个项目甚至部分因为环境问题无法安装的项目（常见于深度学习方面），使用虚拟环境都能有效的解决。 Python 的虚拟环境目前有自带的 venv 和 virtualenv，也有基于此开发的功能更加强大的 poetry 和 pdm，这些工具都很好用，但相对较为复杂，需要用户对虚拟环境有一定的理解后才能顺利的使用。 这里笔者更推荐新手使用 conda，conda 是一个跨平台、多语言的虚拟环境管理工具，相较于前文提到的的虚拟环境在解释器层面的虚拟化，conda 更像是虚拟开发环境，每个环境都是一个“独立”的 Python。因此相较于前者，conda 不需要额外安装 Python解释器，只需要安装 conda 即可直接在环境创建中安装指定版本的 Python 解释器。 但 conda 也有一个严重的缺点，就是较高的磁盘空间占用。由于其跨语言的特性，conda 的虚拟环境管理远不如 poetry 和 pdm 来的精细，并且一个环境就附带一个 python 解释器也会消耗不少的磁盘空间，至于项目管理的功能更是相较于无虚拟环境几乎没有提升，因此 conda 只是一个纯粹的虚拟环境，在单项目依赖较为复杂和需要包管理的情况下，需要配合 poetry 或 pdm 来使用。 不过上述的缺点相对萌新来说远不如其简便的操作与最强的鲁棒性所带来的绝对优势，同时大量科学计算、深度学习等领域也会依赖 conda 环境才能运作，并且 conda 里面也可以套娃安装 pdm 或 poetry（虽然不推荐这么做）。因此对于萌新来说学习 conda 是最好的选择。 conda 的选择conda 目前有两个版本：Anaconda 和 Miniconda。Miniconda 是 conda 的最小实现；Anaconda 中额外包含了常用的深度学习的依赖以及GUI界面。关于二者的选择，可以参考官方的描述。但笔者仅推荐使用 Miniconda，一是因为 Anaconda 中的大多数依赖萌新很难用得到，二是因为 Anaconda 的GUI界面实际上并不好用且非常卡（可能是用 Python 的UI库写的吧），因此没必要浪费额外的磁盘空间去安装 Anaconda。 conda 的安装Windows在 miniconda下载地址 中选择合适的版本进行下载。64位用户可以直接点击这里下载最新版的安装包进行安装。 由于 Windows 下的 miniconda 安装并无什么难度，基本上一路 next 就可以了，在此不进行演示。 千万不要将 miniconda 安装到任意一个Program Files路径下，此操作将会导致 conda 因权限问题无法使用 注意在安装前最后一步将 miniconda 添加至环境变量。 注意这四个选项一定要全部勾选！这里也推荐勾选第二项以方便在其他程序和终端中进行调用。 conda的基础使用我们来简单介绍一些基础的使用方法，更多指令与操作可以查询官方文档。 使用conda创建虚拟环境创建一个名为 test 的虚拟环境。 创建一个名为 test，且python版本为 3.8 的虚拟环境的虚拟环境。 从已有的虚拟环境 test 复制一份为 test_copy。 使用conda移除虚拟环境移除一个名为 test 的虚拟环境。 查看conda虚拟环境列表 使用conda激活虚拟环境激活一个名为 test 的虚拟环境。 如果激活成功，在用户名前会有环境名的提示，例如： 值得注意的是，Windows PowerShell 默认情况下无法直接激活 conda 虚拟环境，请务必在 Windows 系统中使用 cmd 进行操作或在 PowerShell 中使用 conda init 命令来初始化 conda 的配置。 退出conda虚拟环境 值得注意的是，此命令不包含任何额外的参数。因为一个终端仅能同时激活一个虚拟环境，因此也没有必要指定取消激活的虚拟环境的环境名。 conda环境内的使用由于使用了一个虚拟环境，在这个虚拟环境激活时，我们可以正常的使用 Python 中的绝大部分命令与工具，同时 conda 也提供了一些指令，但在此就不过多阐述了。 对于仅使用虚拟环境这一项功能的用户，我们可以直接使用正常操作 Python 的方式进行操作，例如使用 pip 安装第三方库，使用此环境下中 python 的命令行工具以及交互式编程等等，简而言之就是平时怎么用还怎么用，只要你的虚拟环境是激活的的状态，此环境内的改变是不会影响到其他无关的环境的。 在 VSCode 中应用 Conda 环境在 VSCode 中打开一个 Python 文件之后，可以在编辑器界面的右下角找到当前的的解释器（环境）的版本和名称，单击后便可以自由选择你所需要的解释器（环境）了。 结尾的一些碎碎念正如大家所见，本文并不是一个介绍类的教程，同时也完全没有涉及到 Linux 平台。Python 开发可用的工具有很多，一篇文章也不可能介绍完，本文只介绍了最基础最通用的开发环境，能够满足大部分新手开发者的环境需求，但面对更加复杂的需求显然是不足的。之后有时间的话笔者也会发布一些其他 Python 开发工具和环境配置方面的教程，并会同步在这篇专栏下面。 这里是 Well404，我们下篇文章再见！ 虚拟环境的介绍与选择文章中关于 conda 部分的介绍大部分来源于笔者之前发布的专栏，借此机会也更新了其中过时与描述不准的内容，可以作为拓展资料进行阅读。 一篇文章带你上手Conda、Poetry与Pdm，轻松搭建Python虚拟多版本复杂开发环境"},{"title":"一篇文章带你上手Conda、Poetry与Pdm，轻松搭建Python虚拟多版本复杂开发环境","date":"2022-08-17T14:45:00.000Z","url":"/2022/08/17/%E8%99%9A%E6%8B%9F%E7%8E%AF%E5%A2%83/","categories":[["Python杂谈","/categories/Python%E6%9D%82%E8%B0%88/"]],"content":" ⚠警告受限于笔者的知识储备与开发经验，文章中难免会出现错误或异想天开等不符合实际情况的暴论，请您谨慎甄别取用。如您发现错误结论或其他需要修改的问题，可发送电子邮件至 &#119;&#x65;&#108;&#x6c;&#x5f;&#52;&#48;&#x34;&#64;&#x6f;&#117;&#116;&#108;&#111;&#111;&#107;&#46;&#99;&#x6f;&#x6d; 以联系笔者进行更正。 文章开始前，那么聪明的你可能会有所疑问：“为什么要学多份虚拟环境管理工具？”实际上本文介绍的三者均是成熟的虚拟环境管理工具，并且都可以相互独立运行，但相对的各有各的专场以及不足。在文章中，我们将简要分析其基本用法以及其适应的领域，以帮助你在实际的开发中找到合适的虚拟化方案。 conda Package, dependency and environment management for any language—Python, R, Ruby, Lua, Scala, Java, JavaScript, C/ C++, FORTRAN conda 相对于主流的虚拟环境管理工具，在 python 开发环境中最大的特点便是 “不需要安装python”。但请不要误会，这并不意味着 conda 不需要 python 来运行脚本，而是 conda 不会依赖于系统中已经存在的 python 进行运行。因此 conda 拥有较高的独立性以及强悍的跨版本支持，在多版本管理上，目前仍未出现能够击溃 conda 的存在。 但与此同时，conda 对于虚拟环境的管理便显得非常“力大砖飞”，这也同样归功于其强大的跨版本支持上，通过 conda 可以轻松的在创建虚拟环境时仅需一个参数使用任意一个 python 版本，即便系统中不包含该版本的 python。但与之而来的便是其虚拟环境的实现方式极其暴力，每个虚拟环境中均包含了一个完整的 python，即便是在统一系统中已经有了该版本的 python 解释器也会创建一个新的解释器专供该环境使用。因此，conda 的虚拟环境实际上与主流的虚拟环境存在天壤之别。这也带来了 conda 最大的缺点之一——极度浪费磁盘空间。 本质上，conda 的虚拟环境更像是对整个开发环境的虚拟，而不是 poetry 和 pdm 那种在解释器层面的虚拟，这是它原生支持多种编程语言的原因，也是一些科学计算、深度学习项目唯一指定的开发环境的原因。 也正因如此，conda 相较于其他虚拟环境的管理器来说，其上手难度也相对更低一些，仅需要学会 创建环境、进入环境、退出环境、删除环境 即可轻松使用 conda 了，也就是四条指令的难度，因此对于刚入门的开发者来说，conda 相对于其他传统的虚拟环境也更加容易入门。 因此，对于 conda 的使用，笔者个人看法是建议普通用户中 不理解传统虚拟环境使用方法的新手 以及 多版本开发者 进行使用，当然对于科学计算方面的开发者并没得选，而对于单版本多环境的开发者来说，poetry 或 pdm 是你更好的选择。 conda的优势：简单易学、跨版本、独立性、兼容性极高、科学计算指定环境conda的劣势：体积大、复用度低、实现原理“力大砖飞” 安装conda在版本选择方面，conda 提供了两种工具可供选择：anaconda 与 miniconda。 关于二者的选择，可以参考官方的描述。 anaconda 内置了大量的额外内容，例如大量科学计算、深度学习及数据分析相关的库。也正因如此其官方的推荐硬盘空间是3GB及以上，对于非相关领域的工笔者来说将会付出巨大的空间成本。因此我们将使用的工具实际上是 miniconda，而不是 anaconda。 miniconda 相对于 anaconda 仅保留了虚拟环境相关的功能而去除了大量无关的内容，因此体积更小，官方推荐硬盘空间是500MB及以上，内容仅包含 conda、python、一些依赖以及较为常用的python第三方库例如 pip、zlib 等。 miniconda 由于较为精简，相对于 anaconda 去掉了图形化的管理界面，因此对于“命令行恐惧症患者”来说也可以选择 anaconda 进行图形化操作。不过 conda 的使用方法极为简单，且 anaconda 的GUI界面实际上并不好用且非常卡（可能是用 Python 的UI库写的吧），笔者仍然建议使用 miniconda 与命令行工具进行操作。anaconda 与 miniconda 的命令行操作一致，在此将不会分别进行演示。 conda 官方文档： 官方网站： 下载地址： 下载地址： 一般来说，较新的 conda 的 python 版本仅会影响 base 的环境，对于虚拟环境的使用差别并不大，因此我们仅需要下载对应的最新版并安装即可。 Windows在 miniconda下载地址 中选择合适的版本进行下载。64位用户可以直接点击这里下载最新版的安装包进行安装。 由于 Windows 下的 miniconda 安装并无什么难度，基本上一路 next 就可以了，在此不进行演示。 千万不要将 miniconda 安装到任意一个Program Files路径下，此操作将会导致 conda 因权限问题无法使用 注意在安装前最后一步将 miniconda 添加至环境变量。 注意这四个选项一定要全部勾选！这里也推荐勾选第二项以方便在其他程序和终端中进行调用。 Linux(Ubuntu Server 20.04.4)首先在官网选择合适的版本，并进行下载，然后运行下载好的安装脚本。 然后，系统会弹出使用协议之类的东西，一直按回车键(或按Q跳过)直到显示 Please answer &#39;yes&#39; or &#39;no&#39;:&#39; 并输入 yes 同意协议。此时系统会询问安装路径，一般情况下会安装在当前用户 home directory 的 miniconda 文件夹中，也就是 /home/username/miniconda。 一般情况下我们安装在此处即可，按回车键确认。此时便会开始安装，经过一小段时间的等待之后，我们便可以选择初始化 miniconda 了。 输入 yes 后便完成了安装。不过此时 miniconda 并不在系统变量中，无法直接通过命令调用，体现为： 此时查看该用户的 .bsahrc 文件（cat ~/.bashrc），我们可以看到其文件结尾处被添加了如下内容: 此时，我们只需要重新加载 .bsahrc 或 重启终端 即可正常的导入环境变量了。输入 source ~/.bashrc： 此时我们注意到我们的用户名前多了一个 (base)，这便是 conda 激活了 base 环境（默认环境），此时查询版本信息等就是 miniconda 自带的 python 信息了。 conda的基础使用我们来简单介绍一些基础的使用方法，更多指令与操作可以查询官方文档。 使用conda创建虚拟环境创建一个名为 test 的虚拟环境。 创建一个名为 test，且python版本为 3.8 的虚拟环境的虚拟环境。 从已有的虚拟环境 test 复制一份为 test_copy。 使用conda移除虚拟环境移除一个名为 test 的虚拟环境。 查看conda虚拟环境列表 使用conda激活虚拟环境激活一个名为 test 的虚拟环境。 如果激活成功，在用户名前会有环境名的提示，例如： 值得注意的是，Windows PowerShell 默认情况下无法直接激活 conda 虚拟环境，请务必在 Windows 系统中使用 cmd 进行操作或在 PowerShell 中使用 conda init 命令来初始化 conda 的配置。 退出conda虚拟环境 值得注意的是，此命令不包含任何额外的参数。因为一个终端仅能同时激活一个虚拟环境，因此也没有必要指定取消激活的虚拟环境的环境名。 conda环境内的使用由于使用了一个虚拟环境，在这个虚拟环境激活时，我们可以正常的使用 Python 中的绝大部分命令与工具，同时 conda 也提供了一些指令，但在此就不过多阐述了。 对于仅使用虚拟环境这一项功能的用户，我们可以直接使用正常操作 Python 的方式进行操作，例如使用 pip 安装第三方库，使用此环境下中 python 的命令行工具以及交互式编程等等，简而言之就是平时怎么用还怎么用，只要你的虚拟环境是激活的的状态，此环境内的改变是不会影响到其他无关的环境的。 poetry作为一个传统虚拟环境的实现，poetry 凭借其强大的依赖分析能力被大量项目所推荐的虚拟环境管理工具。 对于绝大部分的开发者而言，poetry 作为首选的虚拟环境管理工具是最优方案，其强大的依赖分析能力、环境封装能力以及庞大的社区均可为你的开发保驾护航，这也是我目前最为推荐所有 python 开发者所掌握的虚拟环境管理工具。 poetry官方文档：项目仓库： 对于 poetry 的使用，笔者个人看法是建议 所有开发者 进行使用，其强大的性能足够满足绝大部分情况的需求（除非你还在使用远古版本的 python）。 poetry的优势：分析能力极强、社区资源丰富、兼容性优秀、使用广泛poetry的劣势：对老旧版本的python不兼容、略微复杂 安装poetry注意：poetry 仅支持 Python2.7 或 Python3.5+ 的版本，如果版本低于此请考虑升级 python 版本或使用其他虚拟环境管理工具（例如 conda）。 使用一键安装命令osx / linux / bashonwindows windows powershell Powershell 手动拉取脚本进行安装在 poetry 的 github 仓库中获取安装脚本后，使用 python 运行。 使用pip安装（不推荐）我们也可以使用 pip 安装 poetry，但这仅在一个空白的环境中是较为合适的，例如用 conda 创建的新环境或新安装的 python，直接使用 pip 安装可能会造成依赖冲突。 添加poetry至环境变量安装完成后，可以尝试使用 poetry --version 来确认其是否安装成功并添加至环境变量，如果无法正常执行可以尝试将其添加至 PATH 中。通常情况下，使用 pip 安装是无需添加至环境变量的（前提是 python 的路径在 PATH 中是正常的），使用脚本进行安装的情况下会在文件的末尾提示其安装位置，例如下文中的 &#123;poetry_home_bin&#125; 字段。 通常情况下，脚本会自动将 poetry 的路径添加至环境变量中，但部分情况下会无法正常添加，所以请一定要注意安装脚本的输出内容！如果添加失败的情况下，我们需要手动将 poetry 的可执行文件添加至环境变量中。 Linux下，通常的安装位置为 $HOME/.poetry/bin，其中 $HOME 为你的用户根目录，例如 /home/well404。我们可以通过 echo $HOME/.poetry/bin 来获取安装位置信息： 并将获取到的信息与 export PATH=$PATH: 拼接，并写入到 .bash_profile 中（如果你用的是 bash 的话）： Windows下，通常安装路径为 %USERPROFILE\\.poetry\\bin，其中 %USERPROFILE 为你的用户目录，例如 C:\\Users\\Well404。由于Windows无法直接通过命令行永久修改 PATH，且永久添加的方法步骤较多但有大量详细的教程，因此请自行查询添加方法，在此不多赘述。 poetry的基础使用创建新项目使用 poetry 新建名为 poetry-demo 的新项目： 其创建的项目结构如下所示： 其中，pyproject.toml 是用于存放项目信息的文件，例如项目名、版本号、依赖等，详情可以参考官方文档。 简单来说，我们可以把这个文件看作高级版的 requirement.txt，其中的信息会在创建项目的时候通过命令行的方式进行询问，因此根据你填入的信息不同，此文件的内容也不会完全相同。 不过，由于 poetry 的诞生早于 PEP621 的提出，其构筑方法与之并不兼容，因此 poetry 与后续所提到的 pdm 虽然都是使用 pyproject.toml 存放项目信息但二者并不兼容！ 转化现有的项目转化一个名为 pre-existing-project 的项目： poetry 会对这个项目进行分析，并生成 pyproject.toml 文件，其过程类似于创建新项目的操作。 调整poetry设置官方文档 通过 poetry config --list 命令，我们可以查看 poetry 的设置。 通过 poetry config 命令，我们可以调节 poetry 的设置。例如： 在此，我们简单了解两个配置项：virtualenvs.create 和 virtualenvs.in-project 当参数 virtualenvs.create 为 true 时，执行 poetry install 或 poetry add 时会检测当前项目是否有虚拟环境，没有就自动创建，默认为 true。 当参数 virtualenvs.in-project 为 true 时，虚拟环境的依赖将会放置于项目的文件夹内，而不是 poetry 默认的 &#123;cache-dir&#125;/virtualenvs，默认为 false。 通常情况下，笔者会将这两项均设置为 true，这将简化我们的工作流程，以及更加方便的管理项目与其依赖。 使用poetry创建虚拟环境通常我们会设置 virtualenvs.create=true 并且直接使用 poetry install 等命令来直接自动创建虚拟环境，不过我们也可以通过 poetry env use 手动创建虚拟环境，或通过 poetry env use &lt;解释器路径&gt; 来手动指定一个 python 解释器。例如： poetry env use C:\\Users\\Well404\\AppData\\Local\\Programs\\Python\\Python310\\python.exe 此命令便是使用了安装在默认路径的 Python3.10 解释器进行项目的创建。 使用poetry激活虚拟环境我们可以通过 poetry run 命令 来直接在该项目的虚拟环境中执行命令，也可以通过 poetry shell 来显式激活这个虚拟环境。 例如我们要运行这个虚拟环境中的 main.py 文件，便可使用 poetry run python main.py 或在 poetry shell 激活后直接输入 python main.py。 使用poetry安装依赖如果项目中已有 pyproject.toml 文件，可使用 poetry install 来直接安装其中所列出的依赖。poetry install --no-dev 参数以跳过 dev 使用的依赖，通常在部署项目时使用。 使用 poetry add &lt;package&gt; 可以在环境中安装新的依赖，例如 poetry add numpy，也可以一次性添加多个依赖 poetry add requests pendulum。 通过 --dev 参数可以指定为 dev 依赖，例如 poetry add pytest --dev。 通过指定版本号也可限定依赖的版本范围，例如 poetry add pendulum@^2.0.5 或 poetry add &quot;pendulum&gt;=2.0.5&quot;。 其他常用命令更多命令以及详细信息可查看官方文档中的介绍。 查看虚拟环境信息 poetry env info 显示虚拟环境所有列表 poetry env list 查看可以更新的依赖 poetry show --outdated 查看项目安装的依赖 poetry show 以树形结构查看项目安装的依赖关系 poetry show --tree pdm 本段内容最后编辑于 2023/02/28，无法保证您看到时内容依旧具有时效性，如果发现过时或错误的内容可以通过文章开头的邮箱联系作者进行修改。 提到 pdm，我们绕不开的一点便是 PEP582。在这个提案中，抛弃虚拟环境是其核心诉求。 This PEP proposes to add to Python a mechanism to automatically recognize a __pypackages__ directory and prefer importing packages installed in this location over user or global site-packages. This will avoid the steps to create, activate or deactivate “virtual environments”. Python will use the __pypackages__ from the base directory of the script when present. 简单来说，便是在一个项目的根目录中存放这个项目所用到的依赖，并在搜索依赖时优先使用项目根目录中的依赖，其次才会在 python 的 site-packages 中去找公共的依赖。 实际上，这一实现的目的与虚拟环境较为类似，都是通过一个独立的空间来存放与该项目相关的依赖信息，而相对于虚拟环境而言，PEP582 有3个非常明显的特点： 指定了一个相对固定的依赖存放位置 兼容公共依赖 并不需要激活/关闭虚拟环境 我们接下来介绍的 pdm 便是目前 PEP582 的实现，同时 pdm 也吸收了 PEP517 和 PEP621，相较于 poetry 在未来会有更强的兼容性。 但 pdm 也并不局限于 PEP582，pdm 也同时支持传统的虚拟环境（virtualenv 和 venv），而这也是目前绝大多数用户使用 pdm 的方法，也是笔者推荐的使用方法。PEP582 所设想的环境管理仍未得到广泛的支持，因此笔者并不建议在任何生产环境中使用这项尚未成熟的方案。 同时，pdm 的开发者 Frost Ming 是国人开发者，并且在项目中添加了中文版的 README，因此我们可以较为轻松的上手这个项目。 pdm 官方文档（英文）： github地址 ： Ming 的博客 ： 虽然上文说了 pdm 这么多好话，但在笔者历时一个月的使用中发现了 pdm 仍然不适合刚入门的新手进行使用，同时老手也在部分情况下不得不使用其他虚拟环境管理工具来规避由 pdm 造成的 bug。 pdm vs poetrypdm 的设计思路和操作逻辑很大程度上来源于 poetry，因此我们可以把二者看为一条赛道上的竞争关系。笔者在这里将以个人的使用体验来比较一下 pdm 与 poetry 的差异。 pdm 的优势： 更加友好的用户体验，其cli设计相对 poetry 更加友好与美观（rich nb） 对 PEP 的支持更加友好，更加符合 python 社区规范 能够直接定位已安装的 python 解释器，不用像 poetry 一样需要自己寻找解释器的位置。 pdm 的劣势： 在使用过程中可能碰到非常离谱的bug（有些是测试不全导致的bug，例如Issue1734，但有一些你都不知道这怎么可能发生的bug，例如找不到VC++的环境） 历史沉淀依然稀薄，用户数量并不多（这会导致现在使用很可能成为“第一个吃螃蟹的人”） 在某些小问题上 pdm 的处理需要让开发者额外操心（例如需要手动将 .pdm.toml 加入.gitignore或删除等） 虽然 pdm 拥有更美好的前景，但目前仍有不少bug需要修复，也有一些细节需要优化，与 poetry 相比在最重要的稳定性上仍略逊一筹。因此笔者在这里并不建议新手现在使用 pdm，但十分建议熟练的开发者更多的使用 pdm 并一起完善 pdm 生态。 总结我们上述介绍的三个虚拟环境管理工具，笔者对其观点为： conda：非传统的实现，多版本python的首选，但不建议用于代替普通的虚拟环境（除非你硬盘很大） poetry：目前的主流，功能很强大，很长一段时间内不会过气 pdm：新起之秀，战未来，国人开发，但目前仍然不建议新手使用 实际上，相对于学习 python 本身，python 的虚拟环境管理工具的难度都不是很高，并且我们也并不需要精通虚拟环境，仅需要知道如何安装，如何使用便足矣。"},{"title":"【NoneBot2】第二章：基础插件编写指南第四节———人家才懒得理你呢","date":"2022-05-09T12:30:00.000Z","url":"/2022/05/09/nonebot/%E3%80%90NoneBot2%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97%E7%AC%AC%E5%9B%9B%E8%8A%82%E2%80%94%E2%80%94%E2%80%94%E4%BA%BA%E5%AE%B6%E6%89%8D%E6%87%92%E5%BE%97%E7%90%86%E4%BD%A0%E5%91%A2/","tags":[["NoneBot2","/tags/NoneBot2/"]],"categories":[["NoneBot2系列教程","/categories/NoneBot2%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"]],"content":"第二章：基础插件编写指南第四节———人家才懒得理你呢本节中，将会学习 priority 优先级、简述事件阻断机制、permission 权限控制以及 rule 模块的使用。 本节前言在接触到不少萌新开发者之后，我发现有不少新手的插件仅注重功能的实现，而不注重 “安全性” 方面的防范，导致机器人经常在群里被大家玩坏，导致账号风控甚至冻结。 我们首先来举几个例子，帮助大家了解一下为何我们要注重机器人的安全性： 你写了一个涩图插件，那么在无内鬼的开车群里可以火力全开，但是在其他群聊里面你就会面临 “正义执行” 的举报，因此我们就需要限制发图频率甚至关闭插件保平安。 你写了一个复读机插件，然后群里还有另外一个机器人也装了复读机插件，那么在触发条件之后这两个机器人很有可能就会互相刷屏，导致直接炸群。 你写了一个爬虫插件，爬取的数据量较大，如果反复触发会导致网站封禁你的ip，这时你就需要过滤掉部分恶意请求。 你写了一个群管插件，可以用于批量清人或禁言等敏感操作，这时你就需要设置仅由部分成员或管理员才能对机器人进行操作。 上述情况实质上的解决方法都是一种——屏蔽掉我们不希望被执行的请求，那么这章的工具将会是你的得力助手。 priority 及 事件阻断priority顾名思义，priority 为事件响应器优先级。在收到一条消息之后，nonebot会按照 升序 的方式逐一尝试使用每个事件响应器，直到事件被阻断（结束）或遍历完全部响应器。官方建议的 priority 取值范围为大于等于1的正整数。 Tips：在nonebot的源码中，使用了 sorted() 函数对 priority 进行排序，也就是说理论上你加载的全部插件的 priorty 放到一个列表里后能够使用 sorted() 排序，那么理论上就不会报错。这意味着你甚至可以传入不止大于等于1的正整数，你可以使用0、负数、浮点数甚至字符串（前提是全部 priority 都使用的是字符串）作为priority。但由于源码中某些重要事件的优先级为0，小于等于0的优先级很有可能会导致不可知的问题，请务必不要这么做！请一定要按照官方的建议，使用大于等于1的正整数作为插件的优先级。 聪明的你可能要提出一些疑问了：“为什么这个 priority 感觉和安全性关系不大呢？”，实际上也正是这样，priority 更多的会被应用在插件间的流程控制上，而配合起事件阻断机制可以对消息进行筛选，将事件拦截在触发之前。 简述事件阻断机制 首先声明一点：这里仅是简述，可能会出现表述不严谨和过分简化的情况，请仅作为辅助理解。 在nonebot接收到事件并进行预处理之后，会将这个事件按照 priority 的顺序进行遍历，当以下情况之一发生的情况时，该事件将不会被继续处理： 有任意事件响应器发出了阻止事件传递信号时。 全部事件响应器均已传递完成，没有其他事件响应器可用。 也就是说，如果事件一直没有被阻断的话，可以被多个事件处理器接受并处理，相对的，如果事件被阻断了，后面的事件响应器即便能对该消息进行处理也不会被触发了。 举个例子：假设有人在群里发了张涩图，那么网速快的群友就能陆续收到这份涩图并开冲，然后被管理员 “OT警察” 看到了，认为影响不好，便撤回了涩图，那么后续的群友就无缘见到这张涩图了。 带入到nonebot的事件处理流程中，便是：机器人接收到消息后会生成一个事件，依次遍历事件响应器，优先级高一些的事件响应器可以更快的响应这个事件，直到某个事件响应器阻断了这个事件，那么后面的事件响应器就不会收到这个事件了。 目前，我们可以通过在事件响应器中添加 block 参数来指定该事件响应器是否会在执行完成后进行阻断，也可以在事件处理函数中使用 matcher.stop_propagation() 来直接阻断该事件 Tips: matcher.stop_propagation() 会直接阻断该事件的传播，也会直接结束该事件的处理流程，类似于在函数中进行 return ，此后的代码将不会被执行。 不同的辅助函数其默认block状态并不相同，因此请务必注意其阻断状态不会影响其他事件响应器的正常执行。 如何使用？聪明的你一定想到了：我们可以通过设置一个优先级最高的事件响应器来检查全部的事件，对于不符合规范的事件可用通过事件阻断机制进行屏蔽。 注意：这种方法并不能拦截全部事件进行检查，而且相对来说功能也比较有限，在此仅作为示例展示，本人更加推荐使用 钩子函数 对事件进行 预处理 的写法，该种写法会在进阶教程中展示（如果我没咕咕咕的话） 实现起来也非常的简单，直接上代码： 当然，在此基础上你可以添加依据群号、qq号、关键词和发言频率等一系列判断措施。 rule模块 官方文档：机器人在实际应用中，往往会接收到多种多样的事件类型，NoneBot2 提供了可自定义的匹配规则 ── Rule。 正如官方文档的描述，rule模块可以在事件还未被处理，在响应器层面实现对消息的过滤。当然，你也可以在事件处理阶段对事件进行判断并且在不符合预期的情况下finish掉这个事件（就像上边的黑名单插件）。不过在事件响应器阶段对事件进行初步筛选可以大幅降低被触发的事件处理流程的数量，也就意味着能更加节约服务器资源，同时也可以减少无效log的数量，方便对日志进行阅读。 当然，使用rule模块的时候，一定要注意不要进行 事件处理，有可能会造成bug，如果需要涉及到事件处理流程的判断，我们还是可以通过强制结束事件来处理的，没必要讲全部判断都一股脑塞到rule中。个人建议的写法为在rule中仅进行简单的判断，进行初步筛选和过滤即可。 我们以判断QQ号为例展示一下使用方法： 不难发现，我们在用于检查的函数中，可以自由引用和事件处理函数中相同的依赖，也就是代码中的 event ，而且使用方法也和正常的处理流程中是一样的。 同时在rule模块中的Rule()能够支持将一个及以上的检查器（也就是user_checker）合并为一个整体进行检查，遵循与规则（一否全否），具体代码实现可以参考官方文档合并匹配规则，在此不多阐述。 permission在机器人的实际应用中，总有一些功能是不适宜在大庭广众下使用的，也有一些敏感的功能仅能供给给机器人拥有者（超级用户）使用的。在nonebot中，Permission就是解决这类问题的存在。 正如同其字面意思，Permission 的作用就是对用户身份进行辨认和过滤，仅允许通过判断的用户触发其所属的事件响应器。 注意：以下部分摘自官方文档 如同 Rule 一样，Permission 可以在定义事件响应器时添加 permission 参数来加以应用，这样 NoneBot2 会在事件响应时检测事件主体的权限。下面我们以 SUPERUSER 为例，对该机制的应用做一下介绍。 在这段代码中，我们事件响应器指定了 SUPERUSER 这样一个权限，那么机器人只会响应超级管理员的 测试超管 命令，并且会响应该超级管理员的连续对话。 提示在这里需要强调的是，Permission 与 Rule 的表现并不相同， Rule 只会在初次响应时生效，在余下的对话中并没有限制事件；但是 Permission 会持续生效，在连续对话中一直对事件主体加以限制。 注意：以上部分摘自官方文档 在nonebot中，permission的权限分为两部分，由 nonebot.permission 提供的 SUPERUSER，以及适配器提供的权限，其中由 onebot.v11 提供的权限有以下几种 权限类型 匹配范围 PRIVATE 全部私聊 PRIVATE_FRIEND 私聊好友 PRIVATE_GROUP 群临时私聊 PRIVATE_OTHER 其他临时私聊 GROUP 全部群聊 GROUP_MEMBER 任意群员 GROUP_ADMIN 群管理 GROUP_OWNER 群主 如同 Rule 一样，Permission 也是由非负整数个 PermissionChecker 组成的，但只需其中一个返回 True 时就会匹配成功。 例如，我们想要匹配私聊或群管理时，可以使用这种写法： 那么这个响应器将会对任意私聊或群聊中的管理员进行响应。"},{"title":"【NoneBot2】第二章：基础插件编写指南第三节———会说话就多说点","date":"2022-03-31T13:30:00.000Z","url":"/2022/03/31/nonebot/%E3%80%90NoneBot2%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%89%E8%8A%82%E2%80%94%E2%80%94%E2%80%94%E4%BC%9A%E8%AF%B4%E8%AF%9D%E5%B0%B1%E5%A4%9A%E8%AF%B4%E7%82%B9/","tags":[["NoneBot2","/tags/NoneBot2/"]],"categories":[["NoneBot2系列教程","/categories/NoneBot2%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"]],"content":"第二章：基础插件编写指南第三节———会说话就多说点本节中，将会学习 Message 的基本概念，以及 CQ码、MessageSegment 及 call_api 的基本用法。 MessageMessage是 nonebot 中 OneBot v11 协议 Message 适配。简单来说，就是你能放进输入框的东西理论上都能用Message进行表示，例如普通的文字、图片或者表情等。我们今天要了解的 MessageSegment 本质上就是Message，和CQ码一样，是方便我们更方便构筑Message的一个工具。 Message不光可以对上述内容进行转义或表达，也可以对其进行拼接，例如 CQ码 和 MessageSegment简单来说，CQ码 和 MessageSegment 均是用于辅助开发者更方便的发送非文本类消息的构造方法，例如图片、语音和at等。 经历过酷Q时代的开发者应该还记得CQ码，在nonebot和gocqhttp中cq码依旧可以使用，而且cq收到的非文本类消息也大多会使用CQ码传递给nonebot，而mirai及其他非QQ客户端的协议是没有CQ码的概念的，并且gocqhttp的CQ码在版本更迭的时候CQ码的表达方式也可能会产生变化，因此目前官方和社区的主流意见是尽量避免直接使用CQ码而转而使用MessageSegment的。 但是，MessageSegment也并非万能。其一是在gocqhttp传回的数据中，大部分依旧是使用cq码构造的，这也就要求我们要响应这些数据的时候需要对cq码进行解析而无法使用MessageSegment。其二是在部分情况下使用MessageSegment发送部分内容的情况下gocqhttp会显示“消息为空”而无法发送，但使用cq码就可以发送的奇怪的bug，而且除我之外也有其他开发者遇到过这个问题，但由于此bug不可稳定复现，仍不清楚其成因以及是否解决。 总而言之，个人给出的建议是优先使用MessageSegment进行发送，在发送失败的情况下可以尝试cq码进行发送。（你问解析？解析不就只有CQ码可以解析吗ԅ(¯﹃¯ԅ)） 使用CQ码首先我们应该知道cq码的构造方法，一般情况下是 [CQ:type,key=value] 这种构造形式，具体的某个CQ码我们可以在gocqhttp的官方文档的 CQ code 板块进行查询。 同时，由于cq码中存在例如 []、:、= 等符号，因此需要对其进行转义才能够正常使用，方法也很简单，只需要用 Message() 即可转义，例如： 这样就可以是这个CQ码正常的被解析成一个@，而不是直接把CQ码原文发出去了。 使用MessageSegment 截止至2022.3.31日，在nonebot官方文档中并没有对onebot协议中的MessageSegment进行介绍，因此在这里将会结合源码和编辑器的提示进行讲解 MessageSegment的使用方法实际上非常简单，基本的用法就是 MessageSegment.xxx() ，并且正如上文所说，MessageSegment本质上是Message类，所以我们不需要用 Message() 对其进行转义。首先我们先输入 MessageSegment. 然后查看编辑器的提示或转到源码，就能看到MessageSegment提供的方法了:我们这里用image进行举例: 这样setu001就是一个Message类的涩图了，理论上和 Message(&#39;[CQ:image,file=]&#39;) 是等效的。 MessageSegment由于功能很多，因此不在此一一演示了，想要用好MessageSegment，需要需要多加利用编辑器的自动补全和语法提示，这样就不必翻源码即可使用了。 call_apicall_api相对于前面介绍的功能更强大，且用法也不复杂，而且覆盖面更广。但之所以call_api并不是我们开发过程中的首选，因为它在一般情况下相对我们正常使用的方法来说，也是稍显复杂的，一般体现在需要填写更多的参数上和没有流程控制的能力。 目前call_api最主要的应用是用于补充nonebot无法原生支持的功能，例如获取用户昵称、同意好友请求或上传群文件这种比较不常见的功能。 个人理解其为类似“瑞士军刀”的存在，什么都能干但并不如专业工具，更何况某些情况下我们需要的功能也只能使用call_api进行实现呢（笑）。 使用方法首先我们需要知道我们对接的客户端有什么样的api，这样我们才能对其发起请求。我们使用的gocqhttp的官方文档中对API有详细的介绍。 call_api的写法目前有两种，bot.call_api(&#39;xxx&#39;, **&#123;key:value&#125;)和bot.xxx(key=value)两种仅写法不同，实质并无影响，可根据自身喜好进行调整。 这里我们以“获取群信息”为例进行写法一的演示。我们需要提供两个数据，其中no_cache为选填字段（是否为选填字段需要自行结合描述和实践进行判断），group_id为必填字段。 这样我们就获得了data这个json格式的返回值，然后进行简单的转义就可以读取了。这里我们再演示一下和“发送消息”，并使用第二种方法进行演示。 由此可见，call_api是依赖于bot对象的，因此在一些特殊的响应器（例如aps）中，我们需要手动获取bot对象，这些就留到用到的时候再讲吧。"},{"title":"使用虚拟机安装ikuai系统进行DHCP多拨","date":"2022-03-25T14:02:00.000Z","url":"/2022/03/25/%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85ikuai%E7%B3%BB%E7%BB%9F%E8%BF%9B%E8%A1%8CDHCP%E5%A4%9A%E6%8B%A8/","categories":[["网络、服务器和软路由","/categories/%E7%BD%91%E7%BB%9C%E3%80%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E8%BD%AF%E8%B7%AF%E7%94%B1/"]],"content":"多图警告：本文全部含有45张图片，使用流量时请慎重观看 声明：本文是基于个人经验所撰写，并不一定准确和效率最高，请务必根据实际情况进行调整和部署。同时多拨有可能涉及其他风险，切勿不要盲目多拨，因使用该技术造成的一切后果均需要由您自己承担，请务必慎重使用。 前言及网络环境由于本人所在的宿舍网络免费，自然速度十分的惨不忍睹，连个360P的视频都能卡死，此时的网络拓扑图如下: 由于整栋楼有三百人左右，因此学校采取了非常“聪明的”方法保证上网速度——IP限速，这也是为什么每次测速的上限速度总是2.5Mbps左右，而日常1Mbps都很难达到。 最初的尝试——AP模式这也是最简单最实用的方法，既然是针对IP的限速，那么将宿舍里的每台设备都直接接入交换机进行IP获取，此时的网络拓扑图如下将路由器仅作为AP使用而不进行二级路由，即可使此路由器接入的设备直连到学校的交换机进行IP获取。这样设置的情况下，每台设备都能获得原先一整个宿舍才能获取的网速，单台设备的网速就大约是700-800KB/s，约5.6-6.4Mbps，而峰值性能甚至能达到1.2MB/s，相对于默认情况已经完全可用了，足以支撑打打网游，看看720P的视频。 目前市面上在售的路由器，除非特别便宜或者特别老的型号，均可以调节成AP模式。 进一步尝试——多拨由于AP模式的成功，发现通过增加IP数量来获取更高的带宽完全可行。但由于单台设备的限速，还是无法突破1.2MB/s峰值和700KB/s平均的限制。 那么，如果让一台设备拥有多个IP的话，是否能让这台设备获取更高的网速呢？ 如何让一台设备获取多个IP路由器的DHCP服务器是根据设备的MAC地址对其分配IP的，那么通过仿造多个MAC进行多次请求即可为这些虚拟设备获取到对应的IP。 如何有效的利用这些IP进行网速提升这个问题实际上非常好解决，因为只要涉及到多拨必然会遇到这个问题，因此与之对应的技术负载均衡往往和多拨一起出现，只要配置好负载均衡，即可有效的把这些IP的网速资源进行整合。 那么此时，网络拓扑图就变成了这样 实践——物理机软路由多拨这种方法其实网上已经教烂了，最简单的方法就是找台有两个（或以上）网口的x86的电脑，刷个ikuai或openwrt进行多拨，实际上我也对此进行了尝试，不过由于一系列原因导致我不得不放弃这个方法（如硬件不兼容、驱动不兼容、macvlan有问题等），但如果你手头上正好有一些废弃的笔记本电脑、淘汰下来的台式机等，我还是很推荐这种方法的。具体的设置流程和下面的虚拟机方法大同小异，主要区别就在于系统的安装和物理设备的架设上，不过并不复杂。 实践——虚拟机软路由多拨正题终于开始了，在正式尝试该方法之前，请务必确保上面AP模式能够切实提升你的网速后再尝试这个方法，否则大概率会失望而归。 下载VMware Workstation Pro具体方法请自行搜索，在此不进行演示。 下载ikuai的系统镜像访问ikuai官网，下载系统镜像。我这里使用的是64位版的，暂不清楚32位是否可行，但理论上并无差异。 在VMware中安装ikuai虚拟机 创建虚拟机 选择典型 选择ikuai的系统镜像 选择Linux，版本选 其他Linux 5.X 内核64位（选其他的可能也行，我没试过） 给虚拟机起个名字，然后选个存放位置 分配硬盘空间和磁盘存储方式，按照实际需求分配即可 安装如下步骤，配置好两个网络适配器 注意：如果你使用的是x64的镜像，需要把内存调到2G或更多，否则镜像会安装失败 调整虚拟网络编辑器，如果没有VMnet0和VMnet可点击添加网络自行添加。 注意：子网IP不一定非得是192.168.31.1，只要不与现有网段冲突即可 初步配置ikuai 开启虚拟机，安装系统 系统重启完成后，更换lan口绑定的网卡，然后输入q退回至主菜单。 更改LAN地址至上一阶段第8步最后设置的网段的第一位，然后输入q退回至主菜单。 手动配置本机IP注意：如果下一步能够直接进行（能直接访问webui），则可以直接跳过这一步 进入控制面板\\所有控制面板项\\网络连接，或按照如图所示进入网络连接 安装图示操作，注意这里修改的是VMnet1，不要改错了 进入webui，进行多拨和负载均衡 访问路由器的地址，账号密码均为admin，然后重新设置密码 点击wan1，绑定eth0，接入方式选基于物理网卡的混合模式，然后选DHCP/动态IP，然后点下保存 按照图示添加若干个vwan，需要手动给vwan编号，mac地址是随机生成的勿动。 如图进行负载均衡设置，把全部线路均设置为启用，负载比例均为1 （可选）设置DHCP服务 如图进入DHCP设置 如图进行配置，注意替换自己所在的网段 如果不是服务正常，就重启DHCP服务 按照“手动配置本机IP”部分，进入到IPv4设置，全选成自动，确认后等待一段时间观察蓝框处是否是Internet 设置网关跃点数 先按照“手动配置本机IP”部分，进入到IPv4设置，然后点击高级，取消勾选自动跃点，把跃点数改成1 在powershell中输入 Get-NetIPInterface 查看VMnet1的跃点数是否是最小的(也就是1) 大功告成去测速网站跑个速度试试吧 总结基于DHCP进行多拨叠速的方法仅适用于一些特定的网络结构，但稍加改动也是能够使用的，像是校园网这种需要登陆的网络，可以用不同同学的校园网账号分别绑定一个DHCP的IP（比如在绑定mwan1的时候把其他mwan暂时禁用，绑完了再去绑第二个），如果有无线网卡的话也可以把这个虚拟机的lan口直通给无线网卡等。 而且，多拨能叠出来的带宽其实并不稳定（至少我这里不稳定），而且也不能发挥每个IP的满速。因此叠多少条最合适，怎么设置效率最高还是需要各位自己去探索的"},{"title":"【NoneBot2】第二章：基础插件编写指南第二节———听得见，说得出","date":"2022-02-11T14:30:07.000Z","url":"/2022/02/11/nonebot/%E3%80%90NoneBot2%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97%E7%AC%AC%E4%BA%8C%E8%8A%82%E2%80%94%E2%80%94%E2%80%94%E5%90%AC%E5%BE%97%E8%A7%81%EF%BC%8C%E8%AF%B4%E5%BE%97%E5%87%BA/","tags":[["NoneBot2","/tags/NoneBot2/"]],"categories":[["NoneBot2系列教程","/categories/NoneBot2%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"]],"content":"本节中，将会初步涉及 事件响应器 与 事件处理 ，但这只是其冰山一角，在后续的教程中将会详细补充。但首先我们需要知道，它们是什么。 事件响应器与事件处理在上一节中，我们将插件比作nonebot的 “意识” ，而意识我们可以简单的理解为由无数 “条件反射” 所组成的（说法并不严谨，仅作为比喻）。那么，事件响应器就是 “条件反射” 中的 “条件” 、事件处理就是 “反射” 。换言之，事件响应器是对于机器人所收到的信息进行检验，满足我们预设的 “条件” 之后就会将信号传导nonebot，进一步去触发事件处理流程的开始，也就是进行 “反射” 。 这部分东西比较多，而且一般来说是按需取用，所以在此不过多介绍，具体可以去查看官方文档，也可以看看现在还没写完的第三章第一节（目前仅会上传github） 开始编写第一个插件（今日人品）作为演示，我们将编写一个占卜今日运气的插件。 该插件的执行流程也就是这个插件会响应什么样的信息，对于这样的信息做出什么样的反应。很多新手在群内对如何实现某种功能进行提问的时候，常常无法正确的表述自己的想法，因此导致浪费了很多时间，还得不到答案。因此，在编写一个较为复杂的插件的时候，可以先用流程图来对插件进行设计，然后再着手编写代码。 我们这个插件的功能十分简单，检测用户发送的“jrrp”或“今日人品”，然后随机生成一个1-100的数字作为人品值发回给用户，并@用户，同一天内该数字理应为同一值。 代码部分 事件响应器因为这个插件需要检测多个关键词，因此我们可以选择 on_keyword() 这个事件响应器，jrrp = on_keyword([&#39;jrrp&#39;,&#39;今日人品&#39;],priority=50)这样，我们就注册好了一个可以对这两个关键词进行响应的事件响应器，不过要注意的的是，这个响应器在用户发送的消息中，只要找到了这个关键词就会触发，因此对于一些常用语请务必慎重设置。 priority其中priority=50是指这个事件响应器的优先度为50，类似于“接口跃点”，优先度的数字越低，则优先度越高，也越早可以对消息进行匹配。 在nonebot中，这个字段的默认值是优先度能设置的最小值1，也就是最优先。 nonebot的事件处理中有事件阻断机制，也就是说，在事件向优先度较低的响应器传递的过程中，一旦被匹配到，并且被阻断了，那么后续的事件响应器将不会再接收到这个事件。 举个例子，假设一群人去食堂打饭，如果每种菜的量只有一份，那么排在队前面的人可以更早的打饭，能打的菜也越多，而排在后面的只能挑前面的人不要的菜了。因此在设置 priority 的时候务必慎重。 事件处理 这部分涉及一些语法糖，因此作为小白暂时还不需要理解，按照格式照抄就行了，这部分的详细讲解也会在之后进行 首先，我们可以用刚刚注册的事件响应器来对一个异步函数进行装饰，就像这样。 这样这个函数就可以为我们进行事件处理了 额外：巧妙地偷懒我们再来回顾一下，这个插件的作用 检测用户发送的“jrrp”或“今日人品”，然后随机生成一个1-100的数字作为人品值发回给用户，并@用户，同一天内该数字理应为同一值。 那么问题出现了：我们如何保证生成的人品值一天内不发生改变？ 比较传统的方法可能就会建立一个数据库，在第一次查询时生成并存储每天每个用户的幸运值，然后在用户第二次及以后查询时返回之前存储的幸运值。但这个方法的缺点也显而易见——更多的代码以及文件读写需求，出错的可能性会上升，性能也更加低下。 在python中，随机数是基于当前时间戳的伪随机数。因此我们可以使用一个固定的随机种子，让随机数变为固定的“随机数”，而同一个用户的随机种子每天变化一次，那么生成的随机数也自然每天变化一次。 因此我们可以使用下面的代码，使用户的qq号 event.get_user_id() 和当天的年月日 date.today().strftime(&quot;%y%m%d&quot;) 来生成一个随机数种子，然后算出今日的随机数。 注：这个方法自然也有致命的缺点，就是“不随机”。在积累大量的数据之后，这个算法可以被轻易的推算出来，并且用于预测接下来的随机数。如果你在做抽卡、抽奖这种东西的话，千万不要使用这种方法！！！ 事件处理的一些方法在这个插件里面，我们使用了 event.get_user_id() 来获取用户的qq号，和 jrrp.finish() 来发送消息并结束这个事件。事件处理的方法有很多，我在这里无法一一展示，仅能列出一些常用的方法，具体还是需要查询官方文档或使用编辑器的自动补全功能进行查询。 eventevent.get_message()获取用户发送的消息，包含文字和图片的cq码，返回值是Message类（做解析之前别忘了转义） event.get_plaintext()获取用户发送的消息，但仅包含文字部分，返回值是str类 event.get_user_id()获取用户qq号，返回值是str类 event.get_session_id()私聊：获取用户qq号，返回值是str类群聊：获取群号和用户qq号的组合，例如 group_群号_qq号 ，返回值是str类 event.is_tome()私聊：返回True，返回值bool类群聊：如果用户@机器人，或者使用了预设的昵称，则返回True，否则False，返回值bool类 matchermatcher.send()用于发送一条消息，发送的对象是触发事件响应器的私聊或群，用法为: 其中matcher就是这个事件处理函数对应的事件响应器，例如 await jrrp.send(&#39;123&#39;) 。 matcher.finish()方法同上，只不过这个方法会结束这个事件，类似于一个函数里的 return （但不完全相同）。 总结根据上边的例子，相信各位应该学会如何编写最基础的交互插件了，在下一节，我们将介绍更多事件响应器以及事件处理的方法，例如图片的发送等。"},{"title":"【NoneBot2】第二章：基础插件编写指南第一节———前置知识","date":"2022-02-10T18:50:07.000Z","url":"/2022/02/11/nonebot/%E3%80%90NoneBot2%E3%80%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%EF%BC%9A%E5%9F%BA%E7%A1%80%E6%8F%92%E4%BB%B6%E7%BC%96%E5%86%99%E6%8C%87%E5%8D%97%E7%AC%AC%E4%B8%80%E8%8A%82%E2%80%94%E2%80%94%E2%80%94%E5%89%8D%E7%BD%AE%E7%9F%A5%E8%AF%86/","tags":[["NoneBot2","/tags/NoneBot2/"]],"categories":[["NoneBot2系列教程","/categories/NoneBot2%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"]],"content":"在这个章节正式开始之前，我们首先需要为接下来的学习奠定一些基础。 python基础由于nonebot是使用了 asyncio 的异步框架，并且使用了较多语法糖，相对来说并不适合新手入门，因此如果这个是你入门python之后的第一个实践项目，请做好十足的心理准备。在此推荐几个个人入门看的python教程 python程序语言设计（视频及网站：中国大学Mooc）  优点: 北京理工大学出品，国家精品课程，目前仍在开课 面向非程序员，零基础人群 完全免费，没有第三方网站付费才能解锁题库啥的骚操作 节奏把控很好，能在短时间内快速上手 有配套练习 有专门的老师可以帮助答疑 缺点： 第二周的课程实际完全用不到，属于是为了迎合大学课程特地加的一节，完全没必要去听 课程深度很浅，基本上就只是半只脚入了门的水平，不足以读懂大部分项目的文档（但是能看懂部分教程） 课程开始时间为2018年，可能已经部分过时了 如果只学这一个课程的话，可能无法看懂本教程的部分内容，完全不足以看懂官方文档。 孙兴华zz（视频：B站）  优点: 讲的非常简单易懂 面向非程序员，零基础人群 完全免费，没有第三方网站付费才能解锁题库啥的骚操作 python相关教程很多，可以作为入门项目的库有不少 缺点： 代码采用了大量中文变量，以及并不十分规范的格式，如果照抄有可能会被大佬嫌弃 深度并不足以阅读nonebot的源码，但是完全可以看懂此教程。 python教程以及有段时间没更了，估计以后接着更的可能性也不高 菜鸟教程（网站：网站）  优点: 基础部分十分全面，进阶部分也有代码示例等 十分适合作为速查手册辅助学习 目前国内面对新手的教程向网站中最好的 适合有编程基础的快速上手 缺点： 没有视频以及答疑 不适合完全没接触过编程的小白硬啃，需要配合上面的视频教程使用 nonebot的目录结构nonebot的目录结构其实并不复杂，按照 官方文档 中的示例，我们可以看到如下的结构： 我们可以把项目的文件分为如下两类： 常规文件顾名思义，常规结构（当然有一些使用nonebot的单文件机器人）中机器人运行中不可或缺的文件，或是常规结构中无法直接删除的文件等。 src文件夹（或以机器人的名字命名的文件夹）该文件夹是我们用于放置插件的文件夹，这个文件夹可以随意起名，甚至不是必须存在的，但为了代码的规范以及目录结构的工整，官方的指导建议是将插件放置于 src/plugins 文件夹下。如果没有特殊情况，个人建议按照官方的建议，将插件放置在指定位置，并且使用 scr 作为其名字而不是机器人的名字，例如 awesome_bot（上面的那个案例就是反例）。这样做的目的是为了达到较高的兼容性，否则部分依赖于路径的插件会无法正常工作 .env.* 文件 注意：在部分操作系统下，以 . 为首的文件会被隐藏，因此，我们需要一些设置才能直接看到这些文件，具体方法请善用搜索引擎自行查找。 顾名思义，用于储存环境变量的文件，其中 .env 文件一般用于指向另外两个文件。其中的内容一般为 ENVIRONMENT=prod 或 ENVIRONMENT=dev 中的一种，分别指向下面介绍的两个配置文件。 实际上，你可以在 .env 中直接填写配置，而不需要指向另外两个配置文件。在指向另外的文件的时候，.env 中的内容也会被添加至环境变量一同加载。如果配置文件中的内容有所冲突，此处可参考 官方文档 对此的描述: bot.py 文件( nonebot.init ) &gt; 系统环境变量 &gt; .env, .env.* 文件 .env.prod 文件是用于 生产环境 的环境变量存储，也就是日常使用的环境。.env.dev 文件是用于 测试环境 的环境变量存储，也就是编写插件或者其他测试的时候使用的，一般来说会开启一些实验性功能以及更加详细的log，能为我们debug提供更多信息。 注意：这两个文件中起决定性差距的并不是文件名，而且其中的内容，例如你可以在 .env.prod 中开启debug模式，也可以不在 .env.dev 中开启任何测试性内容。但从实际出发，个人是十分不推荐这么做的，请务必不要这么做！！！ 在实际使用中，我们一般来说可以把无论哪个环境都需要加载的环境变量填写到 .env 中，对于某种特定环境变量填写在对应的环境变量中。 bot.py 文件相当于机器人的心脏，在这个文件中执行了机器人的初始化以及插件加载等操作。由于其中的代码与其他文件和其他插件有较强的的关联性，因此不在此单独说明。 pyproject.toml 文件项目插件配置文件，一般来说是存储一些项目信息的文件，包括自动导入插件等操作。在 bot.py 中对应的加载代码为 nonebot.load_from_toml(&quot;pyproject.toml&quot;) 重要以下纯属依据我浅薄的经验得出的个人观点，希望各位结合实际合理选择操作方法，而不是单纯听信我的一家之言，盲目反对官方的目录结构安排不合理。 但我个人是并不建议使用这个文件进行自动导入的，理由如下： 我们可以用其他更加直观可控的方法进行插件加载等操作，例如 nonebot.load_plugin(&#39;插件名字&#39;) 这个文件是配合 nb-cli 中提供的脚手架进行使用的，相对第一条中的方法有编辑器进行语法提示来说有更高的翻车风险。 最重要的一点，在部分环境下，pyproject.toml 并不能正常的导入插件（详细可见视频），也就是在不同的环境下可能会导致完全不一样的结果。 因此，我一般会在 bot.py 中直接将 nonebot.load_from_toml(&quot;pyproject.toml&quot;) 这行代码直接注释掉或删除。 其他文件在常规的部署方法下，该部分的文件可直接删除，而不会对机器人的正常使用造成任何影响。 docker相关的文件docker-compose.yml 以及 Dockerfile官方提供的 docker 支持，在之后可能会出的docker部署教程会介绍。 其他文件.gitignore 以及 README.md类似于谁都不会看的说明书吧，对机器人来说没什么用。 (￣ε(#￣) nonebot的插件官方文档中对插件的介绍假如说使用nonebot搭建的机器人是一个人的话，nonebot可以理解为这个机器人的身体，能够做出各种各样的行为，但并不能产生自我意识。而插件则是这个人体中的“意识”，仅凭自己是无法独立存在的，但可以依赖身体做出行为，对身体进行指导。 插件放在哪？理论上，你放在哪里都可以，就像你可以把Windows中的程序安装在任何系统允许的位置。但从可读性以及历史角度出发，nonebot中的插件一般来说有两个相对固定的存放位置 site-packages也就是python的第三方库的存放位置，这里可以直接使用 nonebot.load_plugin() 来进行载入，一般来说，你从插件商店下载的插件就会存在这里。 scr/plugins上文中提及到的目录，在此不再次赘述。可以使用 nonebot.load_plugins(&quot;src/plugins&quot;) 来加载该文件夹中的插件。 注意！如果插件的名字首个字符是 _ 的话，那么这个插件将不会被 “自动加载” ，但仍可以使用单独加载的方式进行载入。 插件的结构在nonebot中，插件可以以模块(module)或包(package)的形式导入，这个相信对于编写过多文件脚本的同学并不陌生，这里的模块形式和包形式与python中的定义一致。 模块(module)也就是单文件形式的python脚本，例如下方展示的名为 my_plugin 的插件。 相对于包形式的插件，模块形式的插件更简单，但相对的只能在一个文件中塞下全部代码，因此除非十分简单的插件，不建议使用该形式。 包(package)以一个文件夹形式存在的包，例如下方展示的名为 my_plugin 的插件。 值得注意的是，在python中，一个合法的包中必须含有一个 __init__.py ，即便其中一个字都没有也不能省略。 相对于模块形式的插件，包形式的插件更加灵活美观，是个人比较推荐的插件形式。"},{"title":"【NoneBot2】第一章：安装并配置你的机器人及常见报错的解决方法","date":"2022-02-02T13:11:07.000Z","url":"/2022/02/02/nonebot/%E3%80%90NoneBot2%E3%80%91%E7%AC%AC%E4%B8%80%E7%AB%A0%EF%BC%9A%E5%AE%89%E8%A3%85%E5%B9%B6%E9%85%8D%E7%BD%AE%E4%BD%A0%E7%9A%84%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%8F%8A%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/","tags":[["NoneBot2","/tags/NoneBot2/"]],"categories":[["NoneBot2系列教程","/categories/NoneBot2%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"]],"content":"由于环境安装的内容较为抽象，安装的步骤较为繁琐，建议观看视频教程。本节将会着重介绍常见错误的解决方法。 本章节仅会针对视频中未指出的内容进行补充与拓展，将不会重复已经在视频中提及的内容。 如果你需要提问，请看这里首先，你需要知道的是，这是个开源项目，这篇文章是你免费观看的，nonebot群是你免费加的，没有任何一个开发者和回答问题的人从你这拿走了一分钱。所以，没人对你负有责任，也没人对你有回答问题的义务。 所有人都从新手过来的，自然也不会无理由拒绝一个新人的提问，不过你的态度和提问方法决定了你的提问成功率，所以我在此不负责任的提供一些提高提问成功率的方法： 最重要的是端正你的态度，用相对温和的方式进行提问，富有耐心。 妥善保留 问题发生时 的nonebot日志以及gocq日志，要能清晰的看到错误信息，如果不知道哪里是错误信息就全都保留下来。 使用qq截图 (Ctrl+Alt+A) 或Windows自带的截图 (Win+PrtSc) 或其他截图工具进行截图，切勿使用手机拍屏 尽量详细的描述是什么样的问题，而不是“大佬我这机器人出错了”就完了。 错误的提问 救命啊大佬我这个机器人没反应怎么办啊？（同时不提供任何其他说明和信息） 没有提供日志和截图、也没有详细的描述 这群里没个活人吗，我这机器人打不开了！ 理由同上，不过就算把其他信息补全了我也不会进行任何回答的，态度过于恶劣 私聊：大佬你看看我这机器人怎么回事？ 私聊提问是非常不礼貌的且占用对方时间的行为，大佬回你了是他脾气好，像我这种暴躁老弟一般就不理你了，要是翻来覆去骚扰的话反而会骂你加拉黑。除非对方明确提出私聊，否则不要轻易私聊提问！！！ 我觉得xxxx，所以我这机器人报错了怎么改？不过你说的不对，我觉得就是xxxxx…… 自以为是型选手，自己出了问题解决不了来求助，但是不按照大佬的解决方法走，有一套自己的想法，这种人我建议还是自己去研究吧，唯心主义没人救得了。 大佬你看看我这个机器人xxx报错了，这个是截图（截图之截了非常小一行） 要提问就别怕截图，群友要你的隐私有啥用？这种提问方式不仅和第一种一样没有效率，而且还会更加消磨他人的耐心。 大佬看看我这个问题吧！（此前已经刷了n多次） 没人回答的情况，你应该首先检查自己的提问方法有无问题，提没提供完整的资料。如果你已经完整提供了截图和说明，那么此时应该是没有人能解答你的问题，可以过段时间大佬来水群了再试，而不是一直刷，这样容易被禁言或直接飞机票 大佬我这个机器人……(提了一个重复了无数次的问题) 遇到问题先去尝试自己解决！看看文档和教程，翻翻历史记录，把报错代码粘到浏览器里面搜一下，不会怀孕的！不要一出问题就来问个不停，除非你给个大佬打个红包让他一对一教你，不然再有耐心都会被消磨殆尽的。 把你的机器人打包发我一份谢谢 伸手党型，自己一点脑子也不愿意动，我觉得这种人也不会来看这篇文章的，希望你不是。 待补充，如果之后有啥能让我血压飙升的提问我会在这里补充的 VSCode的常见使用误区工作路径错误由于vscode默认会自动合并窗口，而部分情况下（例如第一个打开的窗口是工作区）会导致工作路径与实际路径不符，导致依赖于相对路径的程序找不到对应的文件，产生报错。 错误特征报错内容为 FileNotFoundError: [Errno 2] No such file or directory: &#39;xxxxx&#39; 。其中xxxxx可以是任意你确定没有丢失的文件的名字，例如 pyproject.toml 。 核实方法也很简单，在使用 nb run 指令不报错的情况下，使用vscode却出现这样的报错一般情况下就是工作路径错误。 或者，我们可以在 bot.py 的最开始处中添加如下代码，然后检查输出的两个路径是否一致。 解决方法解决该问题的方法无非两种，一是正确的设置工作路径，二是在程序内将错误的路径改正即可。 解决方法1在目标文件夹内，右键空白区域，选择使用code打开，然后再次运行即可。 解决方法2关掉目前vscode的全部窗口（最小化的也要关掉），然后再打开 bot.py 。 解决方法3（推荐）按照下图方式，设置新建窗口（从off改为on或者default），这个操作可以一劳永逸的解决这类问题。 解决方法4（推荐）若非开发插件或调试插件，可以直接使用 nb run 命令开启。 解决方法5（强烈推荐）在 bot.py 的 最开始 添加如下代码。 这段代码可以提取bot.py所在的文件夹的位置，并且将工作路径改到该文件夹，相对于上述方法，此方法不仅可以跨平台，也适用于其他python脚本（不止nonebot可用）。 常见报错的解决方法此节将会持续收录常见的报错以及其解决方法。 nonebot与gocqhttp无法建立连接 强烈推荐使用 nonebot-plugin-gocqhttp 插件来构建nonebot与gocq的连接。项目仓库 使用教程  由于nonebot未启动导致无法连接这个就不细说了，自己去找仔细看文章开头的视频，看看哪步出错了，哪个该打开的窗口打不开。 端口号不一致 注：本小节中出现的“这里是端口号”处，均为一个端口号，也就是一个0-65535的数字，在复制粘贴的时候请务必把此处换成合法的端口号 这个错误在gocq端的报错和上个问题一致，均为： 与其不同的是，此时nonebot会有如下提示： 上下文中的端口号并不一致，导致无法成功握手 解决方法就是修改 .env 中的端口号，与gocq的端口号一致即可（具体怎么改去看视频演示） gocq中ws地址填写错误 注：本小节中出现的“这里是端口号”处，均为一个端口号，也就是一个0-65535的数字，在复制粘贴的时候请务必把此处换成合法的端口号 这个问题暂时较为常见（2022年初），因为nonebot2发布新版本（beta1）后，ws地址发生了改变，具体如下： 此问题导致的错误在gocq端的报错为： 此问题导致的错误在nb2端的报错为： 解决办法是将gocq的 config.yml 文件中的旧版地址替换为新版地址，也就是将 cqhttp 替换为 onebot/v11 。同时，造成该问题的也有可能是端口号冲突，在确保ws地址一致情况下，如还发生此问题，请更换一个较为不常见的端口号，例如10000-60000内的一个随机数，且避免23333、x8888、x0022这种具有特殊含义的数。 由于重复导入插件导致的报错错误特征通常在nonebot端输出如下报错 RuntimeError: Plugin already exists: nonebot_plugin_XXXXXX! Check your plugin name 这种错误一般情况是用 nb plugin install 命令后再次手动导入插件导致的，只需要去掉其中一个导入源即可。 解决方法 (较为推荐)打开bot.py，删除或注释掉nonebot.load_from_toml(&quot;pyproject.toml&quot;)，然后手动配置需要导入的插件。 打开bot.py，删除或注释掉nonebot.load_plugin(&quot;nonebot_plugin_XXXXXX&quot;)，其中nonebot_plugin_XXXXXX是报错中提示的插件。 由于beta1版本升级导致的插件不兼容错误特征通常在nonebot端输出如下报错 ModuleNotFoundError: No module named &#39;nonebot.adapters.cqhttp&#39;，也可能产生其他的报错信息，不过此报错是最常见的。 解决方法催作者更新适配（强烈推荐）此方法是最优解，不多解释。不过，记得使用正规渠道（例如github issue）进行合理友善的催更，而不要去骚扰作者。对于弃坑或暂时无法进行适配的作者也要体谅与理解，有能力的话可以给源码进行pr，帮助作者进行适配。 根据版本差异手动适配在无法催作者更新适配的情况下，可以根据视频中的方法进行简易修改，或参照 这个讨论 进行修改。 如果你修改成功了，可以尝试将修改后的代码提交给原作者进行更新哦。 账号风控是企鹅针对第三方机器人的打压行为，为强推自家功能少得可怜而且根本没开放的机器人，以及遏制使用QQ机器人的黑灰产的的一种限制机器人行为的措施，目前呈加剧态势。 错误特征在gocq端出现如下提示：[WARNING]: 群消息发送失败: 账号可能被风控. 解决办法收购企鹅（强烈推荐）你收购企鹅之后，自然就不会有人来风控和冻结你的QQ号了，还能在家躺着赚钱，岂不美哉。 挂一会儿试试万一企鹅大发慈悲给你解除风控了呢 企业账号企业账号是不会风控的，就是开通费有亿点点贵。 换个号换个qq号吧，就当续命了"},{"title":"【NoneBot2】前言——使用NoneBot2搭建QQ机器人","date":"2022-01-30T15:59:07.000Z","url":"/2022/01/30/nonebot/%E3%80%90NoneBot2%E3%80%91%E5%89%8D%E8%A8%80%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8NoneBot2%E6%90%AD%E5%BB%BAQQ%E6%9C%BA%E5%99%A8%E4%BA%BA/","tags":[["NoneBot2","/tags/NoneBot2/"]],"categories":[["NoneBot2系列教程","/categories/NoneBot2%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"]],"content":"什么是nonebot？关于NoneBot2，我们先来引用一下官方文档的描述 NoneBot2 是一个可扩展的 Python 异步机器人框架，它会对机器人收到的事件进行解析和处理，并以插件化的形式，按优先级分发给事件所对应的事件响应器，来完成具体的功能。除了起到解析事件的作用，NoneBot 还为插件提供了大量实用的预设操作和权限控制机制。对于命令处理，它更是提供了完善且易用的会话机制和内部调用机制，以分别适应命令的连续交互和插件内部功能复用等需求。 得益于 Python 的 asyncio (opens new window)机制，NoneBot 处理事件的吞吐量有了很大的保障，再配合 WebSocket 通信方式（也是最建议的通信方式），NoneBot 的性能可以达到 HTTP 通信方式的两倍以上，相较于传统同步 I/O 的 HTTP 通信，更是有质的飞跃。 需要注意的是，NoneBot 仅支持 Python 3.7+ ，个人推荐的开发版本是3.8.10 看起来晦涩难懂？其实要点主要有以下几个： Nonebot2是基于python3.7及以上运行的 框架整体基于异步io 有完善的预设指令，可减轻开发者的工作强度 看到这里，你可能会大呼过瘾。如此优秀的框架已经迫不及待的想要使用了呢！且慢且慢，请先随我一起进行学习，慢慢上手。 如果你决心想要开始nonebot之旅，先让我给你泼盆冷水目前，QQ机器人社区处在一个十分艰难的状态下，一是由于腾讯的打压导致QQ机器人无法正常的工作，二是由于缺少足量的开发者和足够易用的工具（轮子），导致新手入门极为困难，因此如果你决定想要加入nonebot大家庭，那么你首先应该做到以下几点： 有足够的 python 基础以及足够的计算机操作系统的使用经验。计算机使用经验这一点我无法详细说明，由于每个人的情况均有所不同，所以我也无法很好的给出结论，但只会打游戏，其他多一点（如文件格式、路径）都不会还不肯学的的是完全不行的。python 基础方面，由于nonebot是基于asycnio的异步事件处理框架，使用难度上来说，某种程度上甚至高于一些简单的机器学习框架，而一般非专业和部分专业的大学学习的 python 课程是无法达到这个标准的，更别说零基础了。所以在玩转nonebot之前，将会有漫长的学习过程。 有足够的耐心上文也说了，由于开发者较少，nonebot是没有足够的拿来即用的软件生态的（或者说，现在整个机器人社区都是半死不活的状态），因此一些特殊需求很有可能需要你自己动手编写插件才能够实现，这也意味着使用成本的上升。 有足够的心态由于腾讯为了强推自家的机器人，和使用QQ机器人的黑灰产产业猖獗，导致腾讯对于野生机器人采取一棍子打死的态度，现在不光如此，甚至还想来踩上两脚。因此，你在使用机器人的时候说不定什么时候就会被 “风控” ，导致你的机器人发不出任何话，图片和其他炫酷的功能，甚至会导致你的账号冻结。因此，如果你要长期维护一个机器人，这是无法避免的问题。 如果你并没有被前方的艰难险阻劝退的话，欢迎你加入nonebot大家庭对于这个系列教程，我会尽我最大的努力，讲晦涩难懂的知识拆分，用尽量简单的方法教会大家如果使用这个项目。 更新计划视频部分：【零基础搭建QQ机器人】开源、免费、纯新手向的nonebot2.0.0beta版讲解讲解一些环境配置、部署以及其他不适合使用文字表达的部分，作为纯新手入门以及文字部分的补充。 第一章：Hello World——初识NoneBot2 在本章节，你将学会安装并配置你的第一个QQ机器人实例，并且可以掌握一些部署阶段常见的bug的特征以及解决方法，与视频部分相互补充。 第二章：哈？你说啥？——基础插件编写指南 在本章节，你将学会编写最基本的文字和图片的交互的插件。 第三章：在？来张setu？——进阶插件编写指南 在本章节，你将学会使机器人能够响应更多的事件，发送更多种类的信息，以及插件间通信、定时任务框架等。 第四章：你认真读README了吗？——常用API总结 在本章节，我将梳理nonebot及gocqhttp的常用api，并附上实例。 引言（基础知识）在正式开始教程之前，我想对以下几个概念进行说明： 初步认识前端、后端我们先思考一下，如果让你去实现一个QQ机器人，我们需要什么样的程序？如果你现在没有头绪，我们不妨先去看一下这个例子 顾客去饭店点了一份鱼香肉丝 服务员将你点鱼香肉丝的这件事汇报给后厨 后厨的厨师炒出了鱼香肉丝 服务员从后厨取出了鱼香肉丝 服务员把鱼香肉丝交给顾客 在这个过程中，顾客所接触到的人只有服务员，但服务员本身并不进行炒菜的工作，而厨师又始终不知道具体是谁哪位顾客了什么菜，那么这份菜究竟是怎么交付到这位顾客的手中的呢？ 我们再回顾一下第二条与第四条，这两条中服务员与厨师进行了“交互”，通过这种方式将厨师所需要的信息进行了传递。并且将厨师处理完毕的菜交到顾客的手中。 这种结构最大的优点是高度的可替代性和稳定性，例如今天厨师A生病了就可以换用厨师B，服务员Ｃ的老婆生孩子了就可以让服务员D多干一些。而不会出现因为某个环节的部分功能缺失导致全盘崩溃。 我们将目光放回到QQ机器人上，用上述的思路重新进行思考，把顾客、服务员与厨师替换成腾讯的服务器、前端、后端。 前端从腾讯的服务器上接收用户的信息（或其他） 将信息传递给后端 后端对信息进行分析，调用对应的模块进行处理 后端将处理结果推送给前端 前端将处理后的结果重新发送给腾讯的服务器（或其他） 怎么样，是不是一目了然了呢？ 在本篇教程中，我们使用的的前端是go-cqhttp，后端是NoneBot2，他们将很很好的完成上述的工作。 WebSocket WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。 在go-cqhttp与NoneBot的信息交互中，我们使用的就是反向WebSocket连接，也就是说go-cqhttp会主动去寻找nonebot2的程序，并将消息通过ws推送给nonebot2，因此相对于传统的HTTP连接，这种方法明显效率更高，延迟更低。 OneBot标准 OneBot标准是一个聊天机器人应用接口标准，旨在统一不同聊天平台上的机器人应用开发接口，使开发者只需编写一次代码即可应用到多种机器人平台。 在go-cqhttp与NoneBot的信息交互中，通讯的内容是基于OneBot的标准的改版，具体可以参考go-cqhttp的文档。 我们先回顾一下前文中的饭店。如果这个饭店是一个法餐馆，服务生是中国人而厨师是法国人，二者语言并不互通，那么还能够完成点餐的任务吗？明显不能，所以我们会人为要求服务生与厨师都用同一种语言进行交流，而这种语言标准就可以帮助二者有效的沟通。 在两个程序的沟通中，我们需要二者能够识别对方的信息，而不同的开发者不一定会使用一样的交流方式。因此随着OneBot标准的诞生，开发者可以使用这个标准的规范化的语言，那么语言不通的问题就迎刃而解了。 工作路径（Working Directory）、相对路径与绝对路径 The directory in which you are currently working. Path names that do not start with the root directory are assumed by the operating system to start from the working directory————该解释出自 Webopedia 简单来说，工作路径是相当于一个锚点，作为 相对路径 寻找文件的出发点。就类似于你去给别人指路（问路），一般来说会从你现在的位置作为起点进行寻路，那么这个就叫做相对路径。同理，如果现在的位置发生了改变，那么按照相同的路径来寻路自然到不了想要的目的地。 而 绝对路径 则不会受到该问题的影响，类似于从一个固定的建筑指路到目标地 ，那么只要目标地不发生改变，路线自然不会因为你现在的位置不同而出现改变。 那么，绝对路径就比相对路径好？ 答案是否定的。我们不难看出，绝对路径会要求目标地点不能发生改变，而在任意一个操作系统里面，复制和转移文件都是家常便饭的操作，因此，绝对路径的基本要求很难被满足，因此基本上只会出现在一些特殊场合和自己写的简易的脚本上，而无法应对任何位置的改变。 相反，相对路径如果能保证起始位置的准确，是能够在这个整体里面路径的准确的，类似于一个规划图完全相同的游乐园里面，摩天轮的位置相对过山车的位置始终一致，而无论这座游乐园实在北京还是上海。相对于现实中建筑物需要因地制宜进行规划，计算机中一个程序的复制和传播的成本几乎不费吹灰之力，那么相同结构的程序为了能在不同计算机上进行工作，甚至是不同操作系统上进行工作，是绝对无法离开相对路径来维持其内部程序和文件之间的联系的。 那么，这个如此重要的起始位置，就是工作路径。程序会依据起始位置来进行搜索所需要的文件，那么如果起始位置跑了，自然也无法搜索到想要的程序了。 在nonebot中，工作路径位于bot.py的根目录。 在第一节中，我们会了解到vscode如何人为指定工作路径，或通过python自身来修正工作路径。"},{"title":"关于我","date":"1969-12-31T16:00:00.000Z","url":"/1970/01/01/hello-world/","categories":[["undefined",""]],"content":"自我介绍不知道怎么写好，干脆不写了 b站 知乎 Github 邮箱&#x77;&#x65;&#108;&#108;&#95;&#x34;&#48;&#x34;&#x40;&#x6f;&#117;&#x74;&#108;&#x6f;&#x6f;&#107;&#46;&#x63;&#111;&#x6d; 微信公众号、微博、抖音、快手、西瓜、头条……全都没有，如果之后注册了会在这里补充的"}]